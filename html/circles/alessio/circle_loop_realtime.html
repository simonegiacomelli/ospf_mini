<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script type="text/javascript" src="paho-mqtt.js"></script>
    <script type="text/javascript" src="utils.js"></script>
    <script type="text/javascript" src="main.js"></script>

    <style>
        canvas {
            border: 1px solid black;
            width: 100%;
            height: 100%;
            background:url('./images/background.png');
            background-size: 100% 100%;
        }

        body {
            margin: 0;
        }

        #output {
            overflow: auto;
            max-height: 500px;
            border: solid 1px black;
        }
    </style>
</head>
<body>
<h1>This is the recordig done in openspace that loops continuously .</h1>
<button onclick="mqtt.connect()">Connect</button>
<button onclick="mqtt.disconnect()">Disconnect</button>

<canvas></canvas>
<div id="logdiv"></div>
<div id="output"></div>
<script>


    class Circle {
        constructor(ctx, color, coords) {
            this.ctx = ctx;
            this.x = 0;
            this.y = 0;
            this.label = "";
            if (coords !== undefined) {
                this.x = coords[0];
                this.y = coords[1];
            }
            this.radius = 100;
            this.color = color;
            this.fill = false;
        }

        paint() {
            this.ctx.beginPath();
            this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false);
            // this.ctx.stroke();

            this.ctx.fillStyle = this.color;
            if (this.fill)
                this.ctx.fill();
            this.ctx.lineWidth = 5;
            this.ctx.strokeStyle = this.color;

            this.ctx.stroke();

            this.ctx.fillStyle = "black";
            this.ctx.font = "bold 16px Arial";
            this.ctx.fillText(this.label, this.x, this.y);
        }
    }

    class Rectangle {
        constructor(ctx, color, coords, canvas) {
            this.ctx = ctx;

            this.height = 120;
            this.width = canvas.width/4;  
            
            this.x = 0;
            this.y = 0;

            this.label = "";

            if (coords !== undefined) {
                this.x = coords[0];
                this.y = coords[1];
                console.log(this.x,this.y);

            }
            this.color = color;
            this.fill = false;

        }

        paint() {
            this.ctx.beginPath();        
            this.ctx.rect(this.x, this.y, this.width, this.height);
            
            this.ctx.fillStyle = this.color;
            if (this.fill)
                this.ctx.fill();
            this.ctx.lineWidth = 5;
            this.ctx.strokeStyle = this.color;

            this.ctx.stroke();

            this.ctx.fillStyle = "black";
            this.ctx.font = "bold 16px Arial";
            this.ctx.fillText(this.label, this.x, this.y);
            
        }
    }

    class MovingAverage {
        constructor(windowSize) {
            this.list = new Array();
            this.windowSize = windowSize;
            this.sum = 0;
            this.average = 0;
        }

        add(value) {
            this.sum += value;
            this.list.push(value)
            while (this.list.length > this.windowSize) {
                let e = this.list.shift();
                this.sum -= e;
            }
            this.average = this.sum / this.list.length;
        }
    }

    class Beacon {
        constructor(shape, averageWindow) {
            this.shape = shape
            this.values = new MovingAverage(averageWindow);
        }
    }

    class Csv {
        constructor(content) {
            this.t = 0;
            this.lines = content.split('\n');
            this.n = this.lines.length;
            this.rows = Array(this.n);
            for (let i = 0; i < this.n; i++) {
                let line = this.lines[i];
                let vals = line.split(',').map(n => Math.abs(parseFloat(n)));
                this.rows[i] = vals;
            }
        }

        next() {
            this.t++;
            if (this.t >= this.n)
                this.t = 0;
        }

        get(idx) {
            return this.rows[this.t][idx];
        }
    }

    function run() {
        let hotkey = new Hotkey(window);
        hotkey.enableDebug();

        let canvas = document.querySelector('canvas');
        let logdiv = document.getElementById('logdiv');

        function log(line) {
            logdiv.innerHTML += '<br>' + line;
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 100;

        let ctx = canvas.getContext('2d');

        let coords = [[100, 100], [200, 200], [300, 300]];

        let colors = ['red', 'green', 'blue'];
        let names = ['BEN', 'CARL', 'DAVE']
        let beacons = Array(3);


        var selectedBeacon = undefined;
        for (i = 0; i < beacons.length; i++) {
            let idx = i + 1;
            let color = colors[i];
            let rectangle = new Rectangle(ctx, color, coords[i], canvas)
            let movingAverageWindow = 18;
            let beacon = new Beacon(rectangle, movingAverageWindow);
            beacons[i] = beacon;
            hotkey.add("Key" + names[i][0], () => {
                console.log('Selected beacon ' + idx);
                selectedBeacon = beacons[idx - 1];
            });
        }

        function closerBeaconIdx() {
            let m = 1000;
            let res = 0;
            for (let i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                if (m > beacon.values.average) {
                    m = beacon.values.average;
                    res = i;    
                }

            }
            return res;
        }

        canvas.addEventListener('click', (e) => {
            if (selectedBeacon !== undefined) {
                let x = e.offsetX;
                let y = e.offsetY;
                let shape = selectedBeacon.shape;
                console.log(`Moving ${shape.color} to (${x},${y})`);
                shape.x = x;
                shape.y = y;
                selectedBeacon = undefined;
            }
        });

        function loop(time) {  // microsecond timer 1/1,000,000 accuracy in ms 1/1000th
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            let closerIdx = closerBeaconIdx();
            beacons.forEach((b, idx) => {
                b.shape.fill = closerIdx === idx;
                b.shape.paint();
            });

            requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);

        hotkey.add('t', () => {


        });

        mqtt = new MqttClient();
        mqtt.onConnected = () => {
            mqtt.client.subscribe("cyber/rssi");
        };
        mqtt.onMessage = (topic, payload) => {
            let vals = payload.split(',').slice(0, 3).map(n => Math.abs(parseFloat(n)));
            let line = "";
            for (i = 0; i < beacons.length; i++) {
                let beacon = beacons[i];
                let value = vals[i];
                if (value != 0) {
                    beacon.values.add(value);
                    beacon.shape.label = `${names[i]} ${Math.round(beacon.values.average)}`;
                    line = `${line}${Math.round(beacon.values.average)} `
                }
            }
            console.log(line, vals);
        };
        mqtt.connect();

    }
    run();
</script>
</body>
</html>